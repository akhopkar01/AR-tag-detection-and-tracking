# -*- coding: utf-8 -*-
"""Warp_Image.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m6aOA0QF3hUh7ESRmBatozXG6Z2VBs-Z
"""

import cv2
import numpy as np
import math
import copy
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow

#sample points
p1=[[477, 217],[480, 247],[518, 248],[514, 218]]
p2=[[477,217],[477,247],[514,247],[514,217]]

k=np.array([[1406.08415449821,0,0],
    [2.20679787308599, 1417.99930662800,0],
    [1014.13643417416, 566.347754321696,1]]).T
print(k)
def homography(p1, p2):
  A= []
  for val in range(0,len(p1)):
    x_1, y_1 = p1[val][0], p1[val][1]
    x_2, y_2 =p2[val][0], p2[val][1]
    A.append([x_1, y_1, 1 ,0 ,0 ,0, -x_2 * x_1, -x_2 * y_1, -x_2 ])
    A.append([0, 0 ,0 ,x_1, y_1, 1, -y_2*x_1, -y_2 * y_1, -y_2 ])

  A=np.array(A)
  u,S,Vh = np.linalg.svd(A)
  #print(Vh)
  l= Vh[-1,:]/Vh[-1,-1]
  h= np.reshape(l,(3,3))
  return h

def img_perspective(h,k):
  h1= h[:,0]
  h2= h[:,1]
  h3= h[:,2]
  k1= np.linalg.inv(k)
  l= 2/(np.linalg.norm(np.matmul(k1,h1))+ np.linalg.norm(np.matmul(k1,h2)))
  #l1= np.linalg.inv(l)
  bt= l* np.matmul(k1,h)
  det= np.linalg.det(bt)
  if det>0:
    b= bt
  else:
    b= -1*bt

  ro1= b[:,0]
  ro2= b[:,1]
  ro3= np.cross(ro1,ro2)
  t= b[:,2]
  R= np.column_stack((ro1,ro2,ro3,t))
  proj_mat= np.matmul(k,R)
  return proj_mat


h= homography(p1,p2)
img_perspective(h,k)


h1 = cv2.findHomography(np.array(p1),np.array(p2))
print(h1)

#Reading the image and converting to grayscale
tag = cv2.imread("frame2.png", cv2.IMREAD_GRAYSCALE)
tag1 = cv2.resize(tag, (200,356))
rows, cols = tag1.shape
print(rows,cols)
cv2_imshow(tag)

# Creating zero image
new_tag = np.zeros((450,200), dtype=tag.dtype)

P = np.array([[ 1.05663100e+03 , 3.59928907e+02 , 4.56820557e+02 ,-6.71728015e+04],
 [-4.13733532e+01 , 1.32477882e+03 ,-8.24318714e+02 ,-3.34798318e+04],
 [-5.21830645e-02 , 9.81302179e-01 , 4.24189264e-01 , 8.91497512e+02]])

for i in range(rows):
    for j in range(cols):
      new_points = h*np.array([[i],[j],[1]])
      new_points1 = new_points[0:2,0]
      print('The old coordinates are:', (i,j), 'The new coordinates are:', (int(new_points1[0]),abs(int(new_points1[1]))))
      new_tag[int(new_points1[0]), abs(int(new_points1[1]))] = tag1[i][j]

cv2_imshow(new_tag)

